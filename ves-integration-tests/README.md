# VES Integration Tests
This file describes how to execute integration tests against the VES Listener component.
The integration suite consists of several Docker containers as described in the subsections below.
Docker compose is used to orchestrate the containers.

### ves-sdo-collector
This container executes the component under test.
It consumes a POST request on URL '/eventListener/v1'. 
When the listener receives a request on this endpoint it generates a message and sends it to the JMS queue named "O1FmNotifications".
The JBOSS is configured with an internal JMS broker. We have configured the queue "O1FmNotifications" in the standalone-enm.xml config file.

### ves-generator
This container starts a simulator that is used to generate the VES events to be sent to the 'ves-sdo-collector'.

### mongo
This container starts a mongo DB that is required by the 'ves-generator'.

### jms-consumer
**Note:** This container is deliberately not configured in the 'docker-compose.yml' file. The reason for this is that it would break the automated integration tests. If it was running it would consume the messages before they could be confirmed by the tests. The container is left here in case it is needed for manual test execution.

This container starts a JMS consumer that will consume all messages sent to the 'O1FmNotifications' queue.

Build the image with commands:
```
cd ves-integration-tests/jms-consumer
docker build -t jms-consumer .
```
Start the container from the image with the command:
```
docker run --name jms-consumer --network=ves-integration-tests_default jms-consumer
```

# Docker Intallation Notes

## Windows 10

## WSL with docker engine and docker compose

Requirements:

- WSL v2 with Ubuntu (e.g. Ubuntu 22.04)
- Docker engine (Docker version 23.0.2, build 569dd73)
- Docker compose (docker-compose version 1.29.2, build 5becea4c) (Version 2.x.x is not recommended because it's not compatible with the "ci" profile as the command is changed from "docker-compose" to "docker compose" in 2.x.x)
- Note currently Docker Desktop is not allowed without a license in ericsson, if you have a license you can install this instead and skip the steps below.

Steps:

1. Install WSL v2 and Ubuntu 22.04, see https://ubuntu.com/tutorials/install-ubuntu-on-wsl2-on-windows-10#2-install-wsl
2. Install docker engine in WSL, follow the steps here https://confluence-oss.seli.wh.rnd.internal.ericsson.com/display/IDUN/Docker+Installation+on+WSL2+without+Docker+Desktop
3. Install docker compose in WSL, follow the steps here https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-compose-on-ubuntu-20-04

# Test Execution Profiles
The following profiles exist in the 'ves-testsuite' module:
- 'runIntTests': This profile will only execute the integration tests. It requires that the docker containers are already up and running.
- 'ci': This profile will bring up the containers, run the tests, and bring down the containers.

## Profile - runIntTests
This profile will only execute the integration tests. It requires that the docker containers are already up and running.
1. Build Software Artifacts
   From the root directory of the repo execute the following command.
   ```
   mvn clean install
   ```
   This will build the software components and create the executable artifacts.

2. Start Docker Containers
   To start the containers, switch to 'ves-integration-tests' directory and run the command:
   ```
   docker-compose up
   ```
   The 'docker-compose.yml' is used to configure the containers. Refer to it to see what ports are exposed, volumes mounted, images are used etc.

3. Execute Automated Integration Tests
   The 'ves-testsuite' directory contains the automated integration tests.
   These tests trigger events via the 'ves-generator' using the REST Assured test runner.
   They also verify that the JMS message has been generated by consuming the message from the broker.

   Once the containers have all been started, the tests can be executed as follows:
   ```
   cd ves-integration-tests/ves-testsuite
   mvn clean install -PrunIntTests
   ```

4. Execute Manual Test
   It is possible to manually trigger a VES event via the REST interface of the 'ves-generator' using a client such as Postman.

   ##### Generate A Single Event
   POST a request to the URL 'http://localhost:5000/simulator/event' with JSON body: 
   ```
   {
     "vesServerUrl": "http://ves-sdo-collector:8080/eventListener/v1",
     "event": {
       "commonEventHeader": {
         "eventId": "#RandomString(20)",
         "sourceName": "PATCHED_sourceName",
         "version": 3.0
       }
     }
   }
   ```

   ##### Generate Multiple Events Using Templates
   Upload a template via the below URL , to send events of the type defined in the template.
   ```
   URL : http://localhost:5000/template/upload?override=true
   ```
   Initiate the required config to send events to ves-sdo-collector via the following URL:
   ```
   URL : http://localhost:5000/simulator/start
   ```
   [Samples of the payload for the generator can be found here](https://confluence-oss.seli.wh.rnd.internal.ericsson.com/display/NEO/VES+Client+Simulator)

   ##### Verify event was received
   There are a couple of ways to verify if the message was generated depending on the Docker environment setup.

   - If the 'jms-consumer' is running it's possible to verify via it's log that the JMS message was received.
   - If the 'jms-consumer' is not running it's possible to use the JBOSS cli to see if the message exists on the 'O1FmNotifications' queue. To get the number of messages on the queue, execute the command:
        docker exec -it ves-sdo-collector /ericsson/3pp/jboss/bin/jboss-cli.sh -c --controller=0.0.0.0:9990 --user=admin --password=12shroot "/subsystem=messaging-activemq/server=default/jms-queue=O1FmNotifications:read-attribute(name=message-count)"

## Profile - ci
**N.B.** For Windows users its recommended to execute this profile on WSL. This is because the profile may execute the 'wget' command and this is not available by default on git-bash.

This profile will automatically perform the following tasks:
- Bring up the containers using 'docker-compose up'.
- Wait until the ves-generator REST interface is available.
- Execute the integration tests.
- Bring down the containers using 'docker-compose down'.

The profile can be executed from the root directory of the repo via the following command:
```
mvn clean install -Pci
```
# Trouble Shooting 
This section contains some common issues that developers might encounter while running the integration tests.
1. Timeout occurs while running 'ci' profile
   
   ##### Error Message
   The following error message was seen in the console when running the 'ci' profile.
   ```
   > [ves-integration-tests-ves-sdo-collector internal] load metadata for docker.io/daggerok/jboss-eap-7.1:latest:
   ------
   failed to solve: rpc error: code = Unknown desc = failed to solve with frontend dockerfile.v0: failed to create LLB definition: failed to authorize: rpc error: code = Unknown desc = failed to fetch anonymous token: Get "https://auth.docker.io/token?scope=repository%3Adaggerok%2Fjboss-eap-7.1%3Apull&service=registry.docker.io": dial tcp: lookup auth.docker.io on 172.30.64.1:53: read udp 172.30.70.233:41804->172.30.64.1:53: i/o timeout
   [ERROR] Command execution failed.
   org.apache.commons.exec.ExecuteException: Process exited with an error: 17 (Exit value: 17)
   ```
   
   ##### Description
   This error occurs as a result of a timeout while trying to resolve the domain name 'auth.docker.io'.
   ##### Resolution
   The issue was resolved by updating the /etc/resolv.conf file with the following contents:
   ```
   nameserver 193.181.14.10
   nameserver 193.181.14.11
   nameserver 127.0.0.53
   ```

2. 'wait-for' script fails while running 'ci' profile
   ##### Error Message
   The following error message was seen in the console when running the ‘ci’ profile.
   ```
   [INFO] --- exec-maven-plugin:3.0.0:exec (wait-for-ves-generator) @ ves-testsuite ---
   bash: ./wait-for: /bin/sh^M: bad interpreter: No such file or directory
   [ERROR] Command execution failed.
   ```
   
   ##### Description
   This error occurs as the 'wait-for' bash script contains windows file endings.
   The script in the repo should not contain these unless someone mistakenly merged them after modifying the file in a windows text editor.
   This issue will most likely be encoutered as a result of local Git configuration settings. Git can automatically add the windows line endings when you pull a patch.
   
   ##### Resolution
   Confirm if the script has windows file endings with this command:
   ```
   file wait-for
   ```
   If it has window filw ending you will see a response indicating as much, something like this:
   ```
   wait-for: POSIX shell script, ASCII text executable, with CRLF line terminators
   ```
   The text 'with CRLF line terminators' indicates that windows line endings exist.
   They can be removed with this command:
   ```
   sed -i -e 's/\r$//' wait-for
   ```
   However, to prevent them being reintroduced on another pull update the Git 'core.autocrlf' property with value 'input'. Note that if you are developing on windows and you are using WSL, then this property should be set for both environments. 
   ```
   git config --global core.autocrlf input
   ```
   This property configures Git to normalize line endings to LF (Unix-style) when committing, and to not perform any automatic line ending conversions when checking out files.

3. Cannot start container as port already in use
   ##### Error Message
   The following error was see when trying to start the 'ves-generator' container.
   ```
   Error response from daemon: Ports are not available: exposing port TCP 0.0.0.0:5000 -> 0.0.0.0:0: listen tcp 0.0.0.0:5000: bind: address already in use
   ```
   
   ##### Description
   This error was seen on a mac environment only. It was encountered as there was a process called 'ControlCe' already using port 5000.
   
   ##### Resolution
   Check to see what process is using the port:
   ```
   sudo lsof -i :5000
   ```
   If the process is known and is safe to stop, then stop the application corresponding to the process.
   Otherwise update the docker-compose.yml file with a port number that is not being used.
   Note, that if you update the the port used by the 'ves-generator' you will also have to update the port in the following locations:
   ```
   ves-testsuite/src/test/java/com/example/ves/tests/VesListenerIT.java
   ves-testsuite/pom.xml
   ves-generator/properties/application.properties
   ```